## Joscphus问题（约瑟夫环）
[约瑟夫环](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)
这里看图更容易理解问题本质
### 了解递归

### 1. 问题
人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，处刑下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。
问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。

### 2.思考
1. 假设有10（1，2，3，4，5，6，7，8，9，10）个人等待被处决
- 第一次遍历2，4，6，8，10 剩余1,3,5,7,9
- 第二次跳过1从3开始，剩余1，5，9
- 第三次从1开始，剩余5

2. 假设有2*n个人的话
- 第一次遍历删除所有偶数，剩余奇数1，3，5...2n-3,2n-1
- 第二次跳过1从3开始，3其实可以表示为2*2-1,是第一次的编号*2-1
- 那么可以假设J(2n) = 2J(n) - 1 (n>=1)

3. 假设有2*n+1个人的话
- 第一次遍历还是删除偶数，剩余数3,5,...2n-1,2n+1(1遍历2n后紧接着被删掉)
- 第二次从跳过3从5开始，5可以表示为2*2+1
- 那么可以假设J(2n+1) = 2J(n) + 1(n>=1)

可以得出递归公式
J(1) = 1
J(2n) = 2J(n) -1 (n>=1)
J(2n+1) = 2J(n) + 1 (n>=1)

假设公式成立，可以得出表

| n | 1 | 2,3 | 4,5,6,7 | ... |
| -- |:--:|----:|--------:|----:|
| J(n) | 1 | 1,3 | 1,3,5,7 | ... |

表中可以用2的幂来分组，2^0是第一组（1），2^1是（2，3）...
假设幂为m，l为幂分组中的值索引, 则n可以表示成**n = 2^m+l**,
由上述归纳可以得出一个公式J(2^m + l) = 2l + 1（这个公式不知道怎么推导出来的，看起来像是看规律）
因为2^m<=n<2^(m+1)，所以l的范围0<=l<2^(m+1)-2^m=2^m


### 4. 证明J(2^m + l) = 2l + 1
- 假设m=0，根据0<=l<2^m,l一定是0，f(1) = 1成立
- n为偶数的话，f(2^m + l) = 2f(2^(m-1) + l /2) - 1 = 2(2l/2 + 1) -1 =2l+1
- 奇数可以从表得出 因为f(2n+1) - f(2n) = 2,归纳法也可以得出f(2^m + l)=2l+1
**这里的没有推导过程，我看的更像是从归纳法总结得出的结论公式**


### 5. 二进制巧合？
** 因为解和2的幂有关系，所以可以往二进制解题方向靠拢**
归纳得到的公式为n=2^m + l = 2l + 1
n = b(b(m)b(m-1)...b(1)b(0)); (这里是二进制表示数字)
n = b(m)*2^m + b(m-1)*2^(m-1)+...b(1)2 + b(0)1
每个b(i)是0或者1表示二进制的符号，第一位b(m)是1。
因为n=2^m + l
- n = (1b(m-1)b(m-2)...b(1)b(0))
- l = (0b(m-1)b(m-2)...b(1)b(0)) (因为l的取值范围在0和2^m之间)
- 2l = (b(m-1)b(m-2...b(1)b(0)0)) （因为*2所以右移一位）
- 2l + 1 = (b(m-1)b(m-2...b(1)b(0)1)) （最低位+1）
- J(n) = (b(m-1)b(m-2)...b(1)b(0)b(m)) （上面说了b^m是1）

上面的推导得到一个很神奇的公式

J((b(m)b(m-1)...b(1)b(0))) = (b(m-1)...b(1)b(0)b(m))
看起来像是把二进制最高位放到最低位就是解，用归纳法试试
n = 100, J((1100100)) = (1001001) 二进制转化成10进制是73，很神奇。

但事情并不是这么简单的，n=13时候J((1101)) = (1011),然后继续求解J((1011))=(111)
0变成第一位的时候，消失了。重复应用J，最终会到达一个“指定点”，那里J(n) = n，将产生一个
全为1的二进制。







